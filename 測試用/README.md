# JS的作用域(Lexical scope)

作用域就是原始碼起作用的範圍，定義了當前的程式該去哪裡找到這些變數。

作用域又分為**語法作用域**跟**動態作用域**前者指的是函數的作用域在一開始就已經確定了，而後者指的是呼叫函數時才會決定作用域，而**javascript**所採用的是**語法作用域**(又稱為**靜態作用域**)


```
var  value = 1
function  fn1() {
    console.log(value);
}
function  fn2() {
    var  value = 2
    fn1()
}
fn2()
```
上例的程式碼中分別介紹"語法作用域"跟"動態作用域"
- 語法作用域 : `value = 1`的作用域包含全部，所以在fun1()、fun2()都可以讀取到這個值，而`value = 2`的作用域只在fn2( )裡，所以fn1( )裡的值向外查找將是`value = 1`。
- 動態作用域 : 在函式調用是才會決定作用域，所以在fn2()裡調用的fn1()往外查找將是`value = 2`這個值。
---
# JS的執行環境與執行堆疊
所有的程式碼必須在**執行環境**中執行，當網頁被開啟時**全域執行環境**就會被建立。

那執行環境在建立時會經歷兩個階段，分別是 :
- **創造階段(Creation Phase)**
- **執行階段(Execution Phase)**

一旦**全域執行環境**結束**創造階段**，進入**執行階段**時，就會開始由上到下、一行一行的執行程式，如果過程中沒有呼叫任何函式，那麼全域執行環境就是你唯一會遇到的執行環境。
### 如果有函式呼叫呢?
全域環境在執行程式碼的過程中，判讀到**函式呼叫**，**全域執行**環境就會馬上建立全新的**執行環境**運行函式內的程式碼，如果不斷在函式中又呼叫另一個函式就會建立多個**執行環境**，而這些堆疊在一起的**執行環境***，就形成所謂的**執行堆疊**，以下列程式碼來說明執行堆疊。
```
function fn1(){
    fn2();
    console.log('這是第一個function')
}
function fn2(){
    fn3();
    console.log('這是第二個function')
}
function fn3(){
    console.log('這是第三個function')
}
fn1()  // 這是第三個function => 這是第二個function =此> 這是第一個function
```
上述的程式碼會先 => 建立全域執行環境 => 建立 fn1() 執行環境，且堆疊在全域執行環境上 => 建立 fun2() 執行環境，且堆疊在 fn1() 執行環境 => 建立 fn3() 執行環境，且堆疊在 fn2() 執行環境上。

**執行堆疊**的過程是具有**順序性的**，以全域的執行環境為例，是堆疊中的第一層，因為他是最早被建立的**執行環境**。
### 那執行環境甚麼時候被移除呢?
一旦函式執行完並且返回`return`後，該執行環境就會從執行堆疊的最頂端消失，以此類推，直到所有的執行環境都完成任務，從堆疊中移除。





