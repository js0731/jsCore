
# JS提升
在Javascript裡面，如果試圖對一個還沒宣告的變數取值，會回傳`ReferenceError: xxx is not defined`的錯誤，因為你還沒宣告這個變數，自然會發生這樣的錯誤
# JS的執行環境與執行堆疊
所有的程式碼必須在**執行環境**中執行，當網頁被開啟時**全域執行環境**就會被建立。

執行環境在建立時會經歷兩個階段，分別是 :
- **創造階段(Creation Phase)**
- **執行階段(Execution Phase)**

一旦**全域執行環境**結束**創造階段**，進入**執行階段**時，就會開始由上到下、一行一行的執行程式，如果過程中沒有呼叫任何函式，那麼全域執行環境就是你唯一會遇到的執行環境。
### 如果有函式呼叫呢?
全域環境在執行程式碼的過程中，判讀到**函式呼叫**，**全域執行**環境就會馬上建立全新的**執行環境**運行函式內的程式碼，如果不斷在函式中又呼叫另一個函式就會建立多個**執行環境**，而這些堆疊在一起的**執行環境***，就形成所謂的**執行堆疊**，以下列程式碼來說明執行堆疊。
```
function fn1(){
    fn2();
    console.log('這是第一個function')
}
function fn2(){
    fn3();
    console.log('這是第二個function')
}
function fn3(){
    console.log('這是第三個function')
}
fn1()  // 這是第三個function => 這是第二個function =此> 這是第一個function
```
上述的程式碼會先 => 建立全域執行環境 => 建立 fn1() 執行環境，且堆疊在全域執行環境上 => 建立 fun2() 執行環境，堆疊在fn1()執行環境 => 建立 fn3() 執行環境，堆疊在fn2()執行環境上
**執行堆疊**的過程是具有**順序性的**，以全域的執行環境為例，是堆疊中的第一層，因為他是最早被建立的**執行環境**。
### 執行環境甚麼時候被移除 ?
一旦函式執行完並且返回`return`後，該**執行環境**就會從**執行堆疊**的**最頂端消失**，以此類推，直到所有的執行環境都完成任務，從堆疊中移除。

#### JS記憶體的回收機制
在函式的執行環境中都會創造他的記憶體空間，當離開執行環境，且沒有物件參考他時，就會把記憶體空間釋放出來。

---
# JS的作用域(Lexical scope)

作用域就是原始碼起作用的範圍，定義了當前的程式該去哪裡找到這些變數。

作用域又分為**語法作用域**跟**動態作用域**前者指的是函數的作用域在一開始就已經確定了，而後者指的是呼叫函數時才會決定作用域，而**javascript**所採用的是**語法作用域**(又稱為**靜態作用域**)


```
var  value = 1
function  fn1() {
    console.log(value);
}
function  fn2() {
    var  value = 2
    fn1()
}
fn2()
```
上例的程式碼中分別介紹"語法作用域"跟"動態作用域"
- 語法作用域 : `value = 1`的作用域包含全部，所以在fun1()、fun2()都可以讀取到這個值，而JS採用的是**語法作用域**所以跟**執行環境**沒有關連，此時向外查只找將是`value = 1`這個值。
 補充 : 當函式本身沒有這個變數時就會像外層尋找(尋找過程跟執行環境沒有關連)，此過程稱為**範圍練**
- 動態作用域 : 在函式調用是才會決定作用域，所以在 fn2() 裡調用的 fn1() 往外查找將是`value = 2`這個值。
---
# JS的執行緒與同步、非同步
JS屬於**單執行緒**，也就是一次只能執行一個任務，但網頁上的某些任務是**非常耗時**的，例如我們在網頁上下載東西，如果我們須等到下載完，才能做下一個動作的話，那執行效率將會非常的低，所以瀏覽器對這些耗時的任務開闢了另外的執行緒，如
`setTimeout`、`addEventListener`、`ajax`，也就是**無法預期執行時間的操作**，都會以**非同步**處理，丟到**事件佇列(Queue)**，等到**同步執行**的程式碼**執行完**，才會去處理那些被放到**佇列中的任務**。
ex:            
```  
function a() {
    console.log('a');
}
  
function b() {
    setTimeout(function(){
        console.log('b')
    },0)
}

function c() {
    console.log('c');
}

function all() {
    a()
    b()
    c()
}

all()  輸出: a => c => b
```
上述的程式碼就算`setTimeout`就算改為0毫秒，，也不會馬上執行，原因是因為`setTimeout`被放到事件佇列，等到全部的程式碼同步的執行完後，才會執行`setTimeout`裡面的程式碼。
